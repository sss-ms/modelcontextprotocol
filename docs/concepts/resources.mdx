---
title: "资源"
description: "将服务器的数据和内容暴露给 LLM"
---

Resources 是 Model Context Protocol (MCP) 中的一个核心原语，允许服务器暴露可被客户端读取并用作 LLM 交互上下文的数据和内容。

<Note>
  Resources 设计为**应用程序可控**，这意味着客户端应用程序可以决定如何以及何时使用它们。
  不同的 MCP 客户端可能会以不同方式处理 resources。例如：
  - Claude Desktop 目前要求用户在使用 resources 之前明确选择它们
  - 其他客户端可能基于启发式规则自动选择 resources
  - 某些实现甚至可能允许 AI 模型自行决定使用哪些 resources

  在实现 resource 支持时，服务器作者应该准备好处理这些任何交互模式。为了自动向模型暴露数据，服务器作者应该使用**模型可控**的原语，如 [Tools](./tools)。
</Note>

## 概述

Resources 代表 MCP 服务器想要提供给客户端的任何类型的数据。这可以包括：

- 文件内容
- 数据库记录
- API 响应
- 实时系统数据
- 截图和图片
- 日志文件
- 等等

每个 resource 都由唯一的 URI 标识，可以包含文本或二进制数据。

## Resource URI

Resources 使用以下格式的 URI 进行标识：

```
[protocol]://[host]/[path]
```

例如：
- `file:///home/user/documents/report.pdf`
- `postgres://database/customers/schema`
- `screen://localhost/display1`

协议和路径结构由 MCP 服务器实现定义。服务器可以定义自己的自定义 URI 方案。

## Resource 类型

Resources 可以包含两种类型的内容：

### 文本资源

文本资源包含 UTF-8 编码的文本数据。这些适用于：
- 源代码
- 配置文件
- 日志文件
- JSON/XML 数据
- 纯文本

### 二进制资源

二进制资源包含 base64 编码的原始二进制数据。这些适用于：
- 图片
- PDF
- 音频文件
- 视频文件
- 其他非文本格式

## Resource 发现

客户端可以通过两种主要方法发现可用的 resources：

### 直接资源

服务器通过 `resources/list` 端点暴露具体资源列表。每个资源包括：

```typescript
{
  uri: string;           // 资源的唯一标识符
  name: string;          // 人类可读的名称
  description?: string;  // 可选描述
  mimeType?: string;     // 可选 MIME 类型
}
```

### Resource 模板

对于动态资源，服务器可以暴露 [URI 模板](https://datatracker.ietf.org/doc/html/rfc6570)，客户端可以用它来构造有效的资源 URI：

```typescript
{
  uriTemplate: string;   // 遵循 RFC 6570 的 URI 模板
  name: string;          // 此类型的人类可读名称
  description?: string;  // 可选描述
  mimeType?: string;     // 所有匹配资源的可选 MIME 类型
}
```

## 读取 Resources

要读取资源，客户端需要使用资源 URI 发送 `resources/read` 请求。

服务器响应包含资源内容列表：

```typescript
{
  contents: [
    {
      uri: string;        // 资源的 URI
      mimeType?: string;  // 可选 MIME 类型

      // 以下二选一：
      text?: string;      // 用于文本资源
      blob?: string;      // 用于二进制资源（base64 编码）
    }
  ]
}
```

<Tip>
  服务器可能会对一个 `resources/read` 请求返回多个资源。例如，当读取目录时，可以用这种方式返回目录内的文件列表。
</Tip>

## Resource 更新

MCP 通过两种机制支持资源的实时更新：

### 列表变更

服务器可以通过 `notifications/resources/list_changed` 通知来告知客户端其可用资源列表发生变化。

### 内容变更

客户端可以订阅特定资源的更新：

1. 客户端使用资源 URI 发送 `resources/subscribe`
2. 当资源变化时，服务器发送 `notifications/resources/updated`
3. 客户端可以使用 `resources/read` 获取最新内容
4. 客户端可以使用 `resources/unsubscribe` 取消订阅

## 实现示例

这是在 MCP 服务器中实现 resource 支持的简单示例：

<Tabs>
  <Tab title="TypeScript">
    ```typescript
    const server = new Server({
      name: "example-server",
      version: "1.0.0"
    }, {
      capabilities: {
        resources: {}
      }
    });

    // 列出可用资源
    server.setRequestHandler(ListResourcesRequestSchema, async () => {
      return {
        resources: [
          {
            uri: "file:///logs/app.log",
            name: "应用程序日志",
            mimeType: "text/plain"
          }
        ]
      };
    });

    // 读取资源内容
    server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
      const uri = request.params.uri;

      if (uri === "file:///logs/app.log") {
        const logContents = await readLogFile();
        return {
          contents: [
            {
              uri,
              mimeType: "text/plain",
              text: logContents
            }
          ]
        };
      }

      throw new Error("未找到资源");
    });
    ```
  </Tab>
  <Tab title="Python">
    ```python
    app = Server("example-server")

    @app.list_resources()
    async def list_resources() -> list[types.Resource]:
        return [
            types.Resource(
                uri="file:///logs/app.log",
                name="应用程序日志",
                mimeType="text/plain"
            )
        ]

    @app.read_resource()
    async def read_resource(uri: AnyUrl) -> str:
        if str(uri) == "file:///logs/app.log":
            log_contents = await read_log_file()
            return log_contents

        raise ValueError("未找到资源")

    # 启动服务器
    async with stdio_server() as streams:
        await app.run(
            streams[0],
            streams[1],
            app.create_initialization_options()
        )
    ```
  </Tab>
</Tabs>

## 最佳实践

在实现 resource 支持时：

1. 使用清晰、描述性的资源名称和 URI
2. 包含有助于 LLM 理解的描述
3. 在已知时设置适当的 MIME 类型
4. 为动态内容实现资源模板
5. 对频繁变化的资源使用订阅
6. 使用清晰的错误消息优雅地处理错误
7. 考虑大型资源列表的分页
8. 适当缓存资源内容
9. 处理前验证 URI
10. 记录您的自定义 URI 方案

## 安全考虑

在暴露资源时：

- 验证所有资源 URI
- 实现适当的访问控制
- 净化文件路径以防止目录遍历
- 谨慎处理二进制数据
- 考虑资源读取的速率限制
- 审计资源访问
- 加密传输中的敏感数据
- 验证 MIME 类型
- 为长时间运行的读取实现超时
- 适当处理资源清理
---
title: 资源
type: docs
weight: 20
---

{{< callout type="info" >}} **协议版本**: {{< param protocolRevision >}}
{{< /callout >}}

Model Context Protocol (MCP) 为服务器提供了一种标准化的方式来向客户端暴露资源。Resources 允许服务器共享为语言模型提供上下文的数据，如文件、数据库模式或应用程序特定信息。每个资源都由一个 [URI](https://datatracker.ietf.org/doc/html/rfc3986) 唯一标识。

## 用户交互模型

MCP 中的资源被设计为 **application-driven**（应用程序驱动），由宿主应用程序根据其需求决定如何整合上下文。

例如，应用程序可以：

- 通过树形视图或列表视图中的 UI 元素暴露资源以供显式选择
- 允许用户搜索和过滤可用资源
- 基于启发式规则或 AI 模型的选择实现自动上下文包含

![资源上下文选择器示例](resource-picker.png)

然而，实现者可以自由地通过任何适合其需求的界面模式来暴露资源——协议本身不强制要求特定的用户交互模型。

## 功能

支持资源的服务器 **MUST** 声明 `resources` 功能：

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true,
      "listChanged": true
    }
  }
}
```

该功能支持两个可选特性：

- `subscribe`：客户端是否可以订阅单个资源的变更通知。
- `listChanged`：服务器是否会在可用资源列表发生变化时发出通知。

`subscribe` 和 `listChanged` 都是可选的——服务器可以不支持、支持其中之一或同时支持两者：

```json
{
  "capabilities": {
    "resources": {} // 两个特性都不支持
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "subscribe": true // 仅支持订阅
    }
  }
}
```

```json
{
  "capabilities": {
    "resources": {
      "listChanged": true // 仅支持列表变更通知
    }
  }
}
```

## 协议消息

### 列出资源

要发现可用资源，客户端发送 `resources/list` 请求。此操作支持 [分页]({{< ref "/specification/2024-11-05/server/utilities/pagination" >}})。

**请求：**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "resources/list",
  "params": {
    "cursor": "optional-cursor-value"
  }
}
```

**响应：**

```json
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "resources": [
      {
        "uri": "file:///project/src/main.rs",
        "name": "main.rs",
        "description": "主应用程序入口点",
        "mimeType": "text/x-rust"
      }
    ],
    "nextCursor": "next-page-cursor"
  }
}
```

### 读取资源

要检索资源内容，客户端发送 `resources/read` 请求：

**请求：**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "resources/read",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**响应：**

```json
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": {
    "contents": [
      {
        "uri": "file:///project/src/main.rs",
        "mimeType": "text/x-rust",
        "text": "fn main() {\n    println!(\"Hello world!\");\n}"
      }
    ]
  }
}
```

### 资源模板

资源模板允许服务器使用 [URI templates](https://datatracker.ietf.org/doc/html/rfc6570) 暴露参数化资源。参数可以通过 [补全 API]({{< ref "/specification/2024-11-05/server/utilities/completion" >}}) 自动完成。

**请求：**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "method": "resources/templates/list"
}
```

**响应：**

```json
{
  "jsonrpc": "2.0",
  "id": 3,
  "result": {
    "resourceTemplates": [
      {
        "uriTemplate": "file:///{path}",
        "name": "项目文件",
        "description": "访问项目目录中的文件",
        "mimeType": "application/octet-stream"
      }
    ]
  }
}
```

### 列表变更通知

当可用资源列表发生变化时，声明了 `listChanged` 功能的服务器 **SHOULD** 发送通知：

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/list_changed"
}
```

### 订阅

协议支持可选的资源变更订阅。客户端可以订阅特定资源并在其发生变化时接收通知：

**订阅请求：**

```json
{
  "jsonrpc": "2.0",
  "id": 4,
  "method": "resources/subscribe",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

**更新通知：**

```json
{
  "jsonrpc": "2.0",
  "method": "notifications/resources/updated",
  "params": {
    "uri": "file:///project/src/main.rs"
  }
}
```

## 消息流

```mermaid
sequenceDiagram
    participant Client
    participant Server

    Note over Client,Server: 资源发现
    Client->>Server: resources/list
    Server-->>Client: 资源列表

    Note over Client,Server: 资源访问
    Client->>Server: resources/read
    Server-->>Client: 资源内容

    Note over Client,Server: 订阅
    Client->>Server: resources/subscribe
    Server-->>Client: 订阅确认

    Note over Client,Server: 更新
    Server--)Client: notifications/resources/updated
    Client->>Server: resources/read
    Server-->>Client: 更新的内容
```

## 数据类型

### Resource

资源定义包括：

- `uri`：资源的唯一标识符
- `name`：人类可读名称
- `description`：可选描述
- `mimeType`：可选 MIME 类型

### Resource Contents

资源可以包含文本或二进制数据：

#### Text Content

```json
{
  "uri": "file:///example.txt",
  "mimeType": "text/plain",
  "text": "资源内容"
}
```

#### Binary Content

```json
{
  "uri": "file:///example.png",
  "mimeType": "image/png",
  "blob": "base64-encoded-data"
}
```

## 常见 URI 方案

协议定义了几个标准 URI 方案。此列表并非详尽无遗——实现者始终可以自由使用额外的自定义 URI 方案。

### https://

用于表示在网络上可用的资源。

服务器 **SHOULD** 仅在客户端能够直接从网络获取和加载资源时使用此方案——也就是说，它不需要通过 MCP 服务器读取资源。

对于其他用例，服务器 **SHOULD** 优先使用另一个 URI 方案，或定义一个自定义方案，即使服务器本身将通过互联网下载资源内容。

### file://

用于标识行为类似文件系统的资源。但是，这些资源不需要映射到实际的物理文件系统。

MCP 服务器 **MAY** 使用 [XDG MIME type](https://specifications.freedesktop.org/shared-mime-info-spec/0.14/ar01s02.html#id-1.3.14)（如 `inode/directory`）来标识 file:// 资源，以表示没有标准 MIME 类型的非常规文件（如目录）。

### git://

Git 版本控制集成。

## 错误处理

服务器 **SHOULD** 对常见故障情况返回标准的 JSON-RPC 错误：

- 资源未找到：`-32002`
- 内部错误：`-32603`

错误示例：

```json
{
  "jsonrpc": "2.0",
  "id": 5,
  "error": {
    "code": -32002,
    "message": "资源未找到",
    "data": {
      "uri": "file:///nonexistent.txt"
    }
  }
}
```

## 安全注意事项

1. 服务器 **MUST** 验证所有资源 URI
2. **SHOULD** 为敏感资源实现访问控制
3. 二进制数据 **MUST** 正确编码
4. **SHOULD** 在操作前检查资源权限
